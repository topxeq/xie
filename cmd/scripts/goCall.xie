// 给变量a赋值浮点数3.6
// 变量a将在线程中运行的并发函数中被修改
var $a "*any" #f3.6

// 输出当前变量a的值作参考
pl "a=%v, *a=%v" $a *$a

// 调用并发函数
// 第一个参数表示需要压入并发函数所使用的堆栈中的值的数量
// 如果不需要传递参数，第一个参数可以省略
// 第二个参数是字符串形式的并发函数代码
goCall $rs `
    // 弹栈两个传入的参数，注意也不是逆序弹出的而是顺序弹出的
    getArrayItem $arg1 $inputG 0
    getArrayItem $arg2 $inputG 1

    // 查看两个参数值
    pln arg1= $arg1
    pln arg2= $arg2

    // 解引用第一个参数（即主函数中的变量a的应用）
    unref $aNew $arg1

    // 输出变量a的值以供参考
    pln "value in $a is:" $aNew

    // 无限循环演示不停输出时间
    // loop1是用于循环的标号
    :loop1
        // 输出sub和变量arg2中的值
        pln sub $arg2

        // 获取当前时间并存入tmp
        now

        // 将弹栈值（当前时间）赋值给变量arg1指向的变量
        // assignRef的第一个参数必须是一个引用
        assignRef $arg1 $tmp

        // 休眠2秒
        sleep #f2

        // 跳转到标号loop1（实现无限循环）
        goto :loop1
` $a "prefix"

// 主线程中输出变量a的值
// 此时刚开始启动并发函数，变量a中的值有可能还未改变
pln main $a *$a

// 注意，这里的标号loop1虽然与并发函数中的同名，但由于运行在不同的虚拟机中，因此不会冲突，可以看做是两个标号
:loop1

    // 休眠1秒
    sleep #f1.0

    // 输出变量a中的值查看
    // 每隔一秒应该会变成新的时间
    pln a: $a *$a

    // 跳转到标号loop1（实现无限循环）
    goto :loop1