// 新建一个字节指针
// new指令还会为其分配空间
// 因此可以为其赋值
new $a byte 

// sscanf指令类似于其他语言中的sscanf函数
// 将从第一个参数（这里是字符串“a3”）中扫描符合
// 第二个参数“%x”格式符的内容放到后面的变量a中
// 由于a是类型为字节的指针，因为会将a3认为是16进制小写的一个字节的整数，即163
sscanf a3 %x $a

// 解引用变量a中的值，放入变量b中
unref $b $a

// 分别以值、16进制值、二进制值的形式输出b中的数字
pl "%v -> %x -> %b" $b $b $b

// 将b中的数据按位取反放入变量c中
not $c $b

// 分别以值、16进制值、二进制值的形式输出c中的数字
// %08b表示输出二进制数值，如果不够8位则在前面补0
pl "%v -> %x -> %08b" $c $c $c

// 将c中的数据与16进制的0F（即十进制的15，二进制的00001111）进行按位与计算并输出
// 这里用到了复杂表达式计算
// ?作为一个参数的开始，表示后面是一个表达式，可以用反引号括起来以便允许空格字符被正确解析
// unhex指令将把一个字符串按16进制解码为字节列表
// 再用getItem指令取出列表中第一个（序号为0的）字节的值
// 由于0F就是一个字节，因此第一个字节就是整个数的值
pl %08b ?`($c & (? getItem (?unhex 0F) #i0 ) )`

// 将c中的数据与16进制的0F（即十进制的15，二进制的00001111）进行按位或计算并输出
pl %08b ?`($c | (? getItem (?unhex 0F) #i0 ) )`

// 将c中的数据与16进制的0F（即十进制的15，二进制的00001111）进行按位异或计算并输出
pl %08b ?`($c ^ (? getItem (?unhex 0F) #i0 ) )`
